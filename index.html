<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VRâ€‘like Head Tracking (Yaw/Pitch/Roll)</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  video { display: none; }
</style>
</head>
<body>


<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<!-- Face landmarks model -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

<video id="video" autoplay playsinline></video>

<script>
let scene, camera, renderer;
let keys = {};
let model = null;

// head rotation
let yaw = 0, pitch = 0, roll = 0;

init3D();
initCamera();
loadModel().then(() => {
  console.log("Model loaded");
});
animate();

function init3D() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 5);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // floor
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floorMat = new THREE.MeshBasicMaterial({ color: 0x303030 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // some boxes
  const boxGeo = new THREE.BoxGeometry(2, 2, 2);
  const boxMat = new THREE.MeshBasicMaterial({ color: 0x55aaff });
  for (let i = 0; i < 30; i++) {
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set(
      (Math.random() - 0.5) * 100,
      1,
      (Math.random() - 0.5) * 100
    );
    scene.add(box);
  }

  window.addEventListener("keydown", e => keys[e.key] = true);
  window.addEventListener("keyup", e => keys[e.key] = false);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

async function initCamera() {
  const video = document.getElementById("video");
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
}

async function loadModel() {
  model = await faceLandmarksDetection.load(
    faceLandmarksDetection.SupportedPackages.mediapipeFacemesh
  );
}

// simple helper: angle between two points
function angleBetween(p1, p2) {
  const dx = p2[0] - p1[0];
  const dy = p2[1] - p1[1];
  return Math.atan2(dy, dx);
}

async function trackHead() {
  if (!model) return;

  const video = document.getElementById("video");
  if (video.readyState < 2) return;

  const predictions = await model.estimateFaces({ input: video });
  if (!predictions || predictions.length === 0) return;

  const face = predictions[0].scaledMesh;

  // landmarks
  const leftCheek = face[234];
  const rightCheek = face[454];
  const topFace = face[10];
  const bottomFace = face[152];
  const leftEyeOuter = face[33];
  const rightEyeOuter = face[263];

  // yaw: left-right
  yaw = (leftCheek[0] - rightCheek[0]) * 0.002;

  // pitch: up-down
  pitch = (topFace[1] - bottomFace[1]) * 0.002;

  // roll: head tilt (based on eye line angle)
  const eyeAngle = angleBetween(leftEyeOuter, rightEyeOuter);
  // center horizontal is ~0, so use angle directly
  roll = eyeAngle * 0.7; // scale down a bit
}

let lastTrackTime = 0;

function animate(time) {
  requestAnimationFrame(animate);

  // run tracking at ~15 fps to avoid lag
  if (time - lastTrackTime > 66) {
    trackHead();
    lastTrackTime = time;
  }

  // apply head rotation
  camera.rotation.y = yaw;    // yaw
  camera.rotation.x = pitch;  // pitch
  camera.rotation.z = roll;   // roll (tilt)

  // movement
  const speed = 0.2;
  if (keys["w"]) {
    camera.position.x -= Math.sin(camera.rotation.y) * speed;
    camera.position.z -= Math.cos(camera.rotation.y) * speed;
  }
  if (keys["s"]) {
    camera.position.x += Math.sin(camera.rotation.y) * speed;
    camera.position.z += Math.cos(camera.rotation.y) * speed;
  }
  if (keys["a"]) {
    camera.position.x -= Math.cos(camera.rotation.y) * speed;
    camera.position.z += Math.sin(camera.rotation.y) * speed;
  }
  if (keys["d"]) {
    camera.position.x += Math.cos(camera.rotation.y) * speed;
    camera.position.z -= Math.sin(camera.rotation.y) * speed;
  }

  renderer.render(scene, camera);
}
</script>

</body>
</html>
